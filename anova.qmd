---
title: ""
---

### ANOVA

### Comparação entre Três ou Mais Tratamentos

A ANOVA (Análise de Variância) é uma ferramenta estatística utilizada para comparar as médias de três ou mais grupos independentes, com o objetivo de identificar se existem diferenças estatisticamente significativas entre eles. O teste se baseia na estatística F, que avalia a variação entre os grupos em relação à variação dentro dos grupos. A hipótese nula assume que todas as médias são iguais, enquanto a hipótese alternativa sugere que ao menos uma média difere das demais.

### ANOVA com um Fator

Quando se analisa um único fator experimental, a ANOVA é chamada de anova unifatorial. Ela é apropriada em experimentos com delineamento inteiramente casualizado, onde os tratamentos são aplicados aleatoriamente.

**Dados:** Usaremos dados de um experimento que foi conduzido para comparar a taxa de crescimento micelial (TCM) entre diferentes espécies de um fungo fitopatogênico. Neste caso, a variável resposta é a TCM, e o fator em estudo é a espécie do fungo.A hipotese é se a espécie influencia significativamente a taxa de crescimento micelial?

Antes de realizar a análise, é necessário fazer o carregamento dos pacotes estatísticos e a importação dos dados. Em seguida, verifica-se a estrutura do banco e prepara-se o conjunto para as análises de pressupostos e aplicação da ANOVA propriamente dita.

```{r}
library(readxl)
library(tidyverse)
library(dplyr)
library(ggplot2)
micelial <- read_excel("dados-diversos.xlsx", "micelial")
head(micelial)
```

Com a importação dos dados, vamos visualizalos através de um geom_bloxplot:

```{r}
micelial |>
  ggplot(aes(especie, tcm))+
  geom_boxplot(fill = "yellow")
```

### aov()

Para realizar uma ANOVA no R, é necessário criar um modelo estatístico utilizando a função `aov()`, onde se especifica a variável resposta em função do fator (tratamento).

No nosso caso a variável resposta TCM (taxa de crescimento micelial) e o fator espécie. Se os dados estiverem no conjunto chamado `micelial`, o modelo será criado da seguinte forma (aov1 \<- aov(tcm \~ especie, data = micelial)). Após criar o modelo, pode-se obter o quadro de análise de variância com a função summary.

```{r}
aov1 <- aov(tcm ~ especie, data = micelial)
summary(aov1)
```

Esse resumo traz informações como os graus de liberdade, soma de quadrados, valor de F e o p-valor, permitindo avaliar se há diferenças significativas entre os grupos. Assim podemos dizer que nesse conjunto de dados, não há diferença na media micelial, ou seja, não há efeito significativo da espécie sobre o cresc. micelial).

Agora testaremos as premissas:

### **Premissas**

### Teste das Premissas Após a ANOVA

Após realizar a ANOVA, é fundamental verificar se as premissas do modelo foram atendidas, pois isso garante a validade dos resultados. Entre as premissas, a homogeneidade das variâncias (homocedasticidade) é considerada ainda mais crucial que a normalidade dos dados.

**Pacotes recomendados para a verificação**

Para facilitar essa verificação, podemos utilizar dois pacotes do R:

1.  **`performance`**: fornece funções para testar as premissas do modelo, como a função `check_model()`, que oferece um diagnóstico completo;

2.  **`DHARMa`** (Distributed Hierarchical Accumulation of Residuals for Generalized Linear Models): é uma ferramenta avançada para diagnóstico gráfico dos resíduos do modelo, permitindo comparar os resíduos observados com resíduos simulados, ajudando a identificar violações como **não-normalidade** e **heterocedasticidade**.

Além disso, o pacote DHARMa simula resíduos do modelo e os compara visualmente com os resíduos observados, facilitando a identificação de problemas na distribuição dos dados ou na variabilidade dos resíduos. Essa abordagem gráfica complementa os testes estatísticos tradicionais, oferecendo uma avaliação mais intuitiva.Depois dessa análise visual, deve-se realizar o teste formal de normalidade dos resíduos, que combina os resultados da ANOVA e os resíduos obtidos para validar a suposição de normalidade. Esse procedimento assegura que as conclusões do teste sejam confiáveis.

```{r}
library(performance)
check_heteroscedasticity(aov1)
```

```{r}
check_normality(aov1)
```

```{r}
library(DHARMa)
hist (aov1$residuals)
```

Plotando os graficos de residuos:

```{r}
qqnorm(aov1$residuals)
qqline(aov1$residuals)
```

```{r}
plot(simulateResiduals(aov1))
```

```{r}
shapiro.test(aov1$residuals)
```

Podemos assim observar que as premissas foram atendidas, com efeito não significativo das espécies.

### Dados Não Paramétricos

Quando os dados violam as premissas básicas da ANOVA, como a normalidade dos resíduos e a homogeneidade das variâncias, os resultados da análise paramétrica podem se tornar inválidos. Nesses casos, é recomendável utilizar métodos não paramétricos, que são mais robustos e não exigem distribuição normal dos dados.

Usaremos como base o conjunto de dados **`InsectSprays`**, disponível no pacote base **`datasets`** do R. Esse conjunto registra o efeito de diferentes tipos de inseticidas na mortalidade de insetos, conforme descrito em Beall (1942). A variável resposta é o número de insetos mortos, e o fator em estudo é o tipo de spray utilizado. Se, ao aplicar uma ANOVA, as premissas não forem atendidas, uma alternativa adequada é o uso do teste de Kruskal-Wallis, que é o equivalente não paramétrico da ANOVA para comparar três ou mais grupos independentes. Vamos lá?

```{r}
insects <- tibble::as_tibble(InsectSprays) |>
  dplyr::select(spray, count)
insects
```

Vamos visualizar os dados:

```{r}
insects |>
  ggplot(aes(spray, count))+
  geom_boxplot(fill="orange")
```

Bom, aparentemente podemos dizer que os dados se encaixam como não paramétricos, mas antes é preciso fazer anova e checar as premissas:

```{r}
aov2 <- aov(count ~ spray, data = insects)
summary(aov2)
```

```{r}
check_normality(aov2)
```

```{r}
check_heteroscedasticity(aov2)
```

Agora podemos considerar que os dados não seguem normalidade e homogenidade.

Partindo das analises agora vamos avaliar quais alternativas podemos usar para os dados não parametricos:

#### 1. **Transformação dos dados**

Uma abordagem comum é aplicar transformações matemáticas na variável resposta para tentar ajustar os dados às premissas dos testes paramétricos. As transformações mais utilizadas incluem:

-   Raiz quadrada (`sqrt()`)

-   Logaritmo (`log()`)

-   Transformação Box-Cox

Então, vamos lá?

```{r}
aov2 <- aov(sqrt(count) ~ spray, data = insects)
summary(aov2)
```

```{r}
check_normality(aov2)
```

```{r}
check_heteroscedasticity(aov2)
```

#### **2. Testes não paramétricos**

Quando os dados não atendem à normalidade ou homocedasticidade, utiliza-se o teste de Kruskal-Wallis, que compara grupos com base em postos, sem exigir distribuição normal; pode ser executado com o pacote agricolae.

```{r}
kruskal.test(count ~ spray, data = insects)
```

```{r}
library(agricolae)
kruskal(insects$count, insects$spray, 
        console = TRUE)
```

### Pacote emmeans

**emmeans** (Estimated Marginal Means) permite comparar médias ajustadas entre grupos, sendo especialmente útil após modelos lineares (como GLM). Para obter as médias no valor original, usa-se `type = "response"`; `pwpm()` gera a tabela comparativa e `cld()` diferencia os grupos por letras.

```{r}
aov2 <- aov(count ~ spray, data = insects)
summary(aov2)
```

```{r}
check_normality(aov2)
```

```{r}
check_heteroscedasticity(aov2)
```

```{r}
library(emmeans)
aov2_means <- emmeans(aov2, ~ spray,
                         type = "response")
aov2_means
```

```{r}
pwpm(aov2_means)
```

```{r}
library(multcomp)
library(multcompView)
cld(aov2_means)
```

**3. GLM**:

**Modelos Lineares Generalizados (GLM)**: São recomendados para publicações por sua robustez e elegância, evitando transformações nos dados; utiliza-se a função `glm()` com `family = poisson(link = "identity")`, e a verificação do modelo pode ser feita com gráficos do pacote DHARMa.

```{r}
glm1 <- glm(count ~spray,
             data = insects,
             family = poisson(link = "identity"))
plot(simulateResiduals(glm1))
```

```{r}
summary(glm1)
```

```{r}
glm1_means <- emmeans(glm1, ~ spray)
cld(glm1_means)
```

# **Anova Fatorial**

### ANOVA com Dois ou Mais Fatores

Quando a análise envolve dois ou mais fatores, não é possível aplicar testes não paramétricos como o Kruskal-Wallis, que são limitados a comparações unifatoriais. Nesse caso, utiliza-se a função `aov()`, estendendo a fórmula do modelo.

Iremos usar o banco de dados fungicida-vaso, do mesmo conjunto do dados diversos:

```{r}
library(tidyverse)
library(readxl)
dat <- read_excel("dados-diversos.xlsx", "fungicida_vaso")
```

Agora vamos calcular a % do numero de espigas com doenças, criando uma nova coluna:

```{r}
dat2 <- dat |>
  mutate(inc = dis_sp / n_sp*100)

dat2 |>
  ggplot(aes(x = treat,
             y = inc))+
  geom_jitter(width = 0.1)+
  facet_wrap(~dose)
```

Vamos gerar um modelo anova, tratando-os como dados qualitativos:

```{r}
m1 <- aov(inc ~treat*dose, 
          dat = dat2)
summary(m1)
```

Vamos checar premissas:

```{r}
library(performance)
check_normality(m1)
```

```{r}
check_heteroscedasticity(m1)
```

Vamos visualizar com DHARMa:

```{r}
library(DHARMa)
plot(simulateResiduals(m1))
```

Embora, a normalidade tenha apresentado anormalidade, vamos tentar tranformar os dados usando log:

```{r}
m1 <- aov(log(inc + 0.5) ~ treat*dose, 
          dat = dat2)
summary(m1)
```

```{r}
check_normality(m1)
```

```{r}
check_heteroscedasticity(m1)
```

```{r}
plot(simulateResiduals(m1))
```

Vamos agora estimar as medias dos tratamentos para cada interação:

```{r}
library(emmeans)
means_m1 <- emmeans(m1, ~ treat | dose,
                    type = "response")
means_m1
```

```{r}
library(multcompView)
library(multcomp)
cld(means_m1)
```

Coeficiente de variação:

```{r}
library(agricolae)
cv.model(m1)
```

## **ANOVA com três fatores**

Aqui vamos usar dados a

```{r}
library(googlesheets4)
library(gsheet)
library(ggplot2)

url <- "https://docs.google.com/spreadsheets/d/1bq2N19DcZdtax2fQW9OHSGMR0X2__Z9T/edit?gid=1507017964#gid=1507017964"

milho <- gsheet2tbl(url)

head(milho)
milho |>
  filter(tempo ==8) |>
  ggplot(aes(factor(tipo), peso_mil,
             color = factor(umidade)))+
  geom_jitter(width = 0.1)+
  facet_wrap(~ umidade)
```

Interação entre tipo de armazenamento e o tempo (8)

```{r}
milho2 <- milho |>
  filter(tempo ==8)

m2 <- aov(peso_mil ~ factor(tipo)*factor(umidade),
          data = milho2)
summary(m2)
```

Tipo de inoculação na incidencia de Fusarium

```{r}
milho3 <- read_excel("dados-diversos.xlsx", "milho")

m4 <- aov(yield ~hybrid*method,
          data = milho3)
summary(m4)
```

```{r}
check_heteroscedasticity(m4)
```

```{r}
plot(simulateResiduals(m4))
```

```{r}
medias_m4 <- emmeans(m4, ~ hybrid)
medias_m4
```

```{r}
cld(medias_m4)
```

Se a interação não der significativa, nos retiramos a interação e deixamos so o fator que teve significancia.

```{r}
m5 <- aov(yield ~hybrid, data = milho3)
summary(m5)
```

```{r}
m4 <- aov(yield ~hybrid,
          data = milho3)
summary(m5)
```

checando a heteroscedasticidade:

```{r}
check_heteroscedasticity(m5)
```

```{r}
plot(simulateResiduals(m5))
```

```{r}
medias_m5 <- emmeans(m5, ~hybrid)
medias_m5
```

```{r}
cld(medias_m5)
```

```{r}
pwpm(medias_m5)
```

### Dados Não Paramétricos com Dois ou Mais Fatores --- Uso de Ranks

Quando se trabalha com dados não paramétricos envolvendo apenas um fator, é possível aplicar transformações, testes não paramétricos (como Kruskal-Wallis) ou modelos lineares generalizados, conforme discutido anteriormente.

No entanto, quando há dois ou mais fatores, especialmente com interação entre eles, os testes não paramétricos convencionais não são adequados. Nesses casos, uma abordagem alternativa é utilizar o método dos postos (rank).

Esse método consiste em transformar os dados em ranks (valores ordenados), permitindo a aplicação de modelos lineares aos dados ranqueados. Com isso, é possível avaliar os efeitos principais e a interação entre os fatores, mesmo quando os pressupostos da ANOVA não são atendidos.

```{r}
fung <- read_excel("dados-diversos.xlsx", "fungicida_vaso")
fung2 <- fung |>
  mutate(inc = inf_seeds/n_seeds*100,
         rank_inc = rank(inc))
rank_anova <- aov(rank_inc ~treat*dose, data = fung2)
summary(rank_anova)
```

vamos usar emmeans para ver as medias em rank:

```{r}
means_rank <- emmeans(rank_anova, ~treat | dose)
cld(means_rank)
```

Agora podemos criar a tabela e colocar os dados originais com os dados rankeados.

# **ANOVA em DBC e parcela subdividida**

## Anova com bloco (DBC)

Vamos usar o conjunto de dados fungicida_campo:

```{r}
library(tidyverse)
library(readxl)
fungicidas <- read_excel("dados-diversos.xlsx", "fungicida_campo")
```

## Modelo Anova com bloco

O modelo de ANOVA com blocos é utilizado quando há uma fonte de variação adicional além dos tratamentos, chamada de bloco. O objetivo dos blocos é controlar a variabilidade entre unidades experimentais que poderiam afetar os resultados, tornando a comparação entre tratamentos mais precisa.

É especialmente útil quando as unidades experimentais são heterogêneas, mas podem ser agrupadas em subconjuntos (blocos) relativamente homogêneos.

No delineamento em blocos, adiciona o sinal de + para adicionar a repetição.

```{r}
names(fungicidas)
aov_fung <- aov(PROD ~ TRAT + BLOCO, data = fungicidas)
summary(aov_fung)
```

Verificando as premissas:

```{r}
library(performance)
library(DHARMa)
check_normality(aov_fung)
```

```{r}
check_heteroscedasticity(aov_fung)
```

```{r}
plot(simulateResiduals(aov_fung))
```

Agora vamos estimar as médias:

```{r}
library(emmeans)
means_fung <- emmeans(aov_fung, ~TRAT)
library(multcomp)
library(multcompView)
cld(means_fung)
```

```{r}
plot(means_fung)+
  coord_flip()+
  theme_minimal()
```

# **Delineamento em parcela subdividida (Split-plot)**

Vamos usar conjunto milho do dados diversos e ajustamos o modelo:

```{r}
milho <- read_excel("dados-diversos.xlsx", "milho")
#modelo
aov_milho_bloco <- aov(index ~ factor(block) + hybrid*method + 
Error(factor(block)/hybrid/method), data = milho)

summary(aov_milho_bloco)
```

